-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.STLC.Syntax.Par
  ( happyError
  , myLexer
  , pProgram
  , pCommand
  , pListCommand
  , pExpr3
  , pExpr2
  , pExpr1
  , pExpr
  , pScopedExpr
  , pPattern
  , pType
  , pType1
  ) where

import Prelude

import qualified Language.STLC.Syntax.Abs
import Language.STLC.Syntax.Lex

}

%name pProgram_internal Program
%name pCommand_internal Command
%name pListCommand_internal ListCommand
%name pExpr3_internal Expr3
%name pExpr2_internal Expr2
%name pExpr1_internal Expr1
%name pExpr_internal Expr
%name pScopedExpr_internal ScopedExpr
%name pPattern_internal Pattern
%name pType_internal Type
%name pType1_internal Type1
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('          { PT _ (TS _ 1)         }
  ')'          { PT _ (TS _ 2)         }
  '+'          { PT _ (TS _ 3)         }
  '-'          { PT _ (TS _ 4)         }
  '->'         { PT _ (TS _ 5)         }
  '.'          { PT _ (TS _ 6)         }
  ':'          { PT _ (TS _ 7)         }
  ';'          { PT _ (TS _ 8)         }
  '='          { PT _ (TS _ 9)         }
  'Bool'       { PT _ (TS _ 10)        }
  'Nat'        { PT _ (TS _ 11)        }
  'check'      { PT _ (TS _ 12)        }
  'compute'    { PT _ (TS _ 13)        }
  'else'       { PT _ (TS _ 14)        }
  'if'         { PT _ (TS _ 15)        }
  'in'         { PT _ (TS _ 16)        }
  'iszero'     { PT _ (TS _ 17)        }
  'let'        { PT _ (TS _ 18)        }
  'then'       { PT _ (TS _ 19)        }
  'λ'          { PT _ (TS _ 20)        }
  L_NatIdent   { PT _ (T_NatIdent _)   }
  L_TrueIdent  { PT _ (T_TrueIdent _)  }
  L_FalseIdent { PT _ (T_FalseIdent _) }
  L_VarIdent   { PT _ (T_VarIdent _)   }

%%

NatIdent :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.NatIdent) }
NatIdent  : L_NatIdent { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.NatIdent (tokenText $1)) }

TrueIdent :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.TrueIdent) }
TrueIdent  : L_TrueIdent { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.TrueIdent (tokenText $1)) }

FalseIdent :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.FalseIdent) }
FalseIdent  : L_FalseIdent { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.FalseIdent (tokenText $1)) }

VarIdent :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.VarIdent) }
VarIdent  : L_VarIdent { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.VarIdent (tokenText $1)) }

Program :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Program) }
Program
  : ListCommand { (fst $1, Language.STLC.Syntax.Abs.AProgram (fst $1) (snd $1)) }

Command :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Command) }
Command
  : 'check' Expr { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.CommandCheck (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'compute' Expr { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.CommandCompute (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListCommand :: { (Language.STLC.Syntax.Abs.BNFC'Position, [Language.STLC.Syntax.Abs.Command]) }
ListCommand
  : {- empty -} { (Language.STLC.Syntax.Abs.BNFC'NoPosition, []) }
  | Command ';' ListCommand { (fst $1, (:) (snd $1) (snd $3)) }

Expr3 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Expr) }
Expr3
  : VarIdent { (fst $1, Language.STLC.Syntax.Abs.EVar (fst $1) (snd $1)) }
  | NatIdent { (fst $1, Language.STLC.Syntax.Abs.EConstNat (fst $1) (snd $1)) }
  | TrueIdent { (fst $1, Language.STLC.Syntax.Abs.EConstTrue (fst $1) (snd $1)) }
  | FalseIdent { (fst $1, Language.STLC.Syntax.Abs.EConstFalse (fst $1) (snd $1)) }
  | '(' Expr ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Expr2 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Expr) }
Expr2
  : Expr2 '+' Expr2 { (fst $1, Language.STLC.Syntax.Abs.EAdd (fst $1) (snd $1) (snd $3)) }
  | Expr2 '-' Expr2 { (fst $1, Language.STLC.Syntax.Abs.ESub (fst $1) (snd $1) (snd $3)) }
  | 'iszero' '(' Expr ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.EIsZero (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | Expr3 { (fst $1, (snd $1)) }

Expr1 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Expr) }
Expr1
  : 'λ' Pattern '.' ScopedExpr { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ELam (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Expr2 { (fst $1, (snd $1)) }

Expr :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Expr) }
Expr
  : Expr1 Expr { (fst $1, Language.STLC.Syntax.Abs.EApp (fst $1) (snd $1) (snd $2)) }
  | 'if' Expr 'then' Expr 'else' Expr { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.EIf (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | 'let' Pattern '=' Expr 'in' ScopedExpr { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.ELet (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | Expr ':' Type { (fst $1, Language.STLC.Syntax.Abs.ETyped (fst $1) (snd $1) (snd $3)) }
  | Expr1 { (fst $1, (snd $1)) }

ScopedExpr :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.ScopedExpr) }
ScopedExpr
  : Expr { (fst $1, Language.STLC.Syntax.Abs.AScopedExpr (fst $1) (snd $1)) }

Pattern :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Pattern) }
Pattern
  : VarIdent { (fst $1, Language.STLC.Syntax.Abs.PatternVar (fst $1) (snd $1)) }

Type :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type
  : Type1 '->' Type { (fst $1, Language.STLC.Syntax.Abs.TFunc (fst $1) (snd $1) (snd $3)) }
  | Type1 { (fst $1, (snd $1)) }

Type1 :: { (Language.STLC.Syntax.Abs.BNFC'Position, Language.STLC.Syntax.Abs.Type) }
Type1
  : 'Nat' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.TNat (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'Bool' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), Language.STLC.Syntax.Abs.TBool (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1))) }
  | '(' Type ')' { (uncurry Language.STLC.Syntax.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Language.STLC.Syntax.Abs.Program
pProgram = fmap snd . pProgram_internal

pCommand :: [Token] -> Err Language.STLC.Syntax.Abs.Command
pCommand = fmap snd . pCommand_internal

pListCommand :: [Token] -> Err [Language.STLC.Syntax.Abs.Command]
pListCommand = fmap snd . pListCommand_internal

pExpr3 :: [Token] -> Err Language.STLC.Syntax.Abs.Expr
pExpr3 = fmap snd . pExpr3_internal

pExpr2 :: [Token] -> Err Language.STLC.Syntax.Abs.Expr
pExpr2 = fmap snd . pExpr2_internal

pExpr1 :: [Token] -> Err Language.STLC.Syntax.Abs.Expr
pExpr1 = fmap snd . pExpr1_internal

pExpr :: [Token] -> Err Language.STLC.Syntax.Abs.Expr
pExpr = fmap snd . pExpr_internal

pScopedExpr :: [Token] -> Err Language.STLC.Syntax.Abs.ScopedExpr
pScopedExpr = fmap snd . pScopedExpr_internal

pPattern :: [Token] -> Err Language.STLC.Syntax.Abs.Pattern
pPattern = fmap snd . pPattern_internal

pType :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType = fmap snd . pType_internal

pType1 :: [Token] -> Err Language.STLC.Syntax.Abs.Type
pType1 = fmap snd . pType1_internal
}

